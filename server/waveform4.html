<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="description" content="">
    <meta name="author" content="jm3">
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <title>d3 audio waveforms</title>
    
    <!--<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Roboto:400,100|Raleway:400,200|Amatic+SC"> -->
    <style>
		* {
		  margin:      0;
		  font-family: Helvetica, Arial;
		}
		html {
		  margin: 1.0em;
		}
		h1 {
		  font-size:    48px;
		  font-weight:  bold;
		}
		h1 a,
		h1 a:visited {
		  text-decoration:  none;
		  font-weight:      normal;
		  font-size:        90%;
		  color:            #000;
		  border-bottom:    1px dashed #bbb;
		}
		h1 a:hover {
		  color: red;
		}
		.waveform > svg,
		.waveform > div {
		  border:       2px solid #ddd;
		  height:       140px;
		  margin-left:  20px;
		  padding:      2px;
		  position:     relative;
		  width:        600px;												/* Change width to incorporate more elements, but reduce points */
		  display:  	inline-block;
	
		}
		h2 {
		  margin-left:  3px;
		  font-size:    22px;
		  color: 		#999;
		  position: 	absolute;
		}
		.waveform > div div.bar {
		  background-color:  red;
		  position:  absolute;
		}
		.waveform .svg1 g rect {
		  fill:     red;
		  /*opacity:  0.5;*/
		}
		.waveform .svg2 g rect {
		  fill:     green;
		  /*opacity:  0.5;*/
		}
		
		.marquee{
		  color: #666;
		  font-size: 12px;
		  position: absolute;
		  top: calc(100% - 14px);
		  width: 100%;
		  height: 100%;
		  animation: marquee 28.4s linear; 
		  white-space: nowrap;
		}
		
		@keyframes marquee {
		  100% { transform: translateX(-100%); }
		}
		
    </style> 
  </head>
  <body> 
    <div class="page">
      <div class="waveform">
        <div class="svg1"><h2>DJ's Home</h2></div>								
        <div class="svg2"><h2>DJ's Office</h2></div>							
      </div>
    </div>

    <script>
	/* Performance is increased by reducing the number of data points or by reducing data updatae time.
	 * If you reduce the number of data points, the granurality is lower and hence you can use the functions below (divide by 2 etc.) to make it all look better.
	 * Another trick (not recommended) is to increase the data updatae time while also increasing the points (coz generating 512 point time is not double of 256 point time)
	 * This way the eye wouldn't see big lines moving too fast....
	 */
		var FIRST_ROOM = "dj-home", SECOND_ROOM = "dj-office", THIRD_ROOM = "jon-office";
		
		var numOfPoints = 512;				// Number of points  = 256. Orig = 1024 (which increases granurality but decreases performance and also decreases speed of updatae of waveform)			
		var min_max_val = 6;	//7.5		// IMP: CHANGE BASED ON MIC VOLUME AND HOW IT LOOKS. Remeber that graph doesn't show all value.
		var max_val = min_max_val;
		
		
		//D3 specific elements
		var width = 600, height = 140;
		var bar_width = width / (numOfPoints);							// Dividing by 2 reduces the number of path points. This allows to reduce the array length above while keeping same granularity (width of bars) by introducing space between the bars	
		
		//var test = [...Array(512)].map(e => Array(2).fill(1));
		svg_creater(Array.from({length: numOfPoints}, () => 0.0), '.svg1', min_max_val);
		svg_creater(Array.from({length: numOfPoints}, () => 0.0), '.svg2', min_max_val);
		//svg_updater(test, '.svg2', min_max_val);
		//console.log(pitch_to_color(1000));
		
		//Sound event specific elements
		var secToPerWidth = sec => sec*100/parseFloat($('.marquee').css('animationDuration'));		//This does not account for width of marquee element. TODO: Also, set the marquee element width based on server handshake (data sample size)
		var lengthOfGapInSec = 1;
		var numOfSamplesPerSec = 20;
		
		/**** data from Socket ****/
		  var socket = io.connect();					//URL is windows.location (url address of the webpage), timeout: 5 days
		  
		  // Send handshake
		  socket.on('connect', function () {
			//socket.receiveBuffer.length = 0;			//Clear buffer
			//socket.sendBuffer.length = 0;
			console.log("Waveform connected to server!");
			socket.emit('handshake', "http-waveform");
		  });
		  
		  socket.on('handshake-server-wave', function (data) {
			data = JSON.parse(data);
			lengthOfGapInSec = parseFloat(data.lengthOfGapInSec);
			numOfSamplesPerSec = parseFloat(data.numOfSamplesPerSec);
			numOfPoints = parseInt(data.numOfWaveformPoints);
		});
      
		  
		  socket.on('responseFromHttpServer', function(data){	
			  data = JSON.parse(data);
			  if(data.clientid == FIRST_ROOM)
			  {
				svg_updater(data.arrayWaveform, ".svg1", min_max_val);		// Note that max_val is updated in the next cycle
				if(data.event != "Blank")
					event_adder(".svg1", data.event, parseFloat(data.duration), lengthOfGapInSec);				
			  }
			  
			  if(data.clientid == SECOND_ROOM)
			  {
				svg_updater(data.arrayWaveform, ".svg2", min_max_val);
				if(data.event != "Blank")
				{
					//console.log(".svg2" + ":" + data.event + ":" + parseFloat(data.duration) + ":" + lengthOfGapInSec);
					event_adder(".svg2", data.event, parseFloat(data.duration), lengthOfGapInSec);
				}	
			  }
			  
			  /* To handle that all waveforms have same y scales for changing y axis */
			  //max_val = d3.max(wave_json1.concat(wave_json2), function(d) { return d; });	//Concat arrays based on number of waveforms
			  //if (max_val < min_max_val) max_val = min_max_val;
		  });
		//event_adder(".svg2", "Loud", 0.75, 1);
		/**** Events *****/
		function event_adder (clas, event, duration, gapLen) {
			var id = new Date().getTime();
			
			$(clas).append("<span class='marquee "+id+"'>" + event + ", " + duration + "s</span>");
		
			var time_adjust = parseFloat($('.marquee').css('animationDuration'))/(numOfPoints/numOfSamplesPerSec);
			var animationDuration = parseFloat($('.marquee').css('animationDuration')) - (duration + gapLen)*time_adjust; 
			$('.'+id).css({'animationDuration': animationDuration + 's'});	
			
			var tra = -secToPerWidth(duration + gapLen);
			$('.'+id).css({'transform': 'translateX('+tra+'%)'});

			setTimeout(function() {
				$('.'+id).remove();
			}, animationDuration*1000);
		}
		
		/**** Waveform *****/
		function svg_creater(data, svg, max_val) {
		  
		  var node = d3.select(svg).append("svg")
			.attr("class","chart")
			.attr("width", width)
			.attr("height", height);
			
		  var y = d3.scale.linear().range([height, -height]);  
		  y.domain([-max_val, max_val]);
		  
		  var bar = node.selectAll("g")
			.data(data)
			.enter().append("g") // svg "group"
			.attr("transform", function(d, i) {
			  return "translate(" + i * bar_width + ",0)";				// Multiplying by 2 reduces the number of path points by adding space between points
			});

		  bar.append("rect")
			.attr("y", function(d) {
			  var yv = height - Math.abs(y(d)/2) - height/2 + 2;
			  return yv;
			})
			.attr("height", function(d) {
			  return Math.abs(y(d)); })
			.attr("width", bar_width);
		}
		
		function svg_updater(data, svg, max_val) {
		  
		  var node = d3.select(svg).select("svg");
		  
		  var y = d3.scale.linear().range([height, -height]);  
		  y.domain([-max_val, max_val]);
		  		  
		  var bar = node.selectAll("g").data(data);

		  bar.select("rect")
			.attr("y", function(d) {
			  var yv = height - Math.abs(y(d[0])/2) - height/2 + 2;
			  return yv;
			})
			.attr("opacity", function(d){
			  return 0.4 + 0.6*d[1]/5000;
			})
			.attr("height", function(d) {
			  return Math.abs(y(d[0])); 
			});
		}
		
		function pitch_to_color2(pitch) {
			var R = 0, G = 0, B = 0;
			if (pitch!= 0)
				B = parseInt(pitch*255/1000);				//anything about > 1000 is mapped to 255
			return "rgb("+R+","+G+","+B+")";
		}
		function pitch_to_color(pitch) {
			if (pitch!= 0)
			{
				var w = parseInt(pitch*(780-380)/5000) + 380;
				
				var R = 0.0, G = 0.0, B = 0.0;
				
				if (w >= 380 && w < 440) {
					R = -(w - 440) / (440 - 350);
					G = 0.0;
					B = 1.0;
				}
				else if(w >= 440 && w < 490) {
					R = 0.0;
					G = (w - 440) / (490 - 440);
					B = 1.0;
				}
				else if(w >= 490 && w < 510) {
					R = 0.0;
					G = 1.0;
					B = -(w - 510) / (510 - 490);
				}
				else if(w >= 510 && w < 580) {
					R = (w - 510) / (580 - 510);
					G = 1.0;
					B = 0.0;
				}
				else if(w >= 580 && w < 645) {
					R = 1.0;
					G = -(w - 645) / (645 - 580);
					B = 0.0;
				}
				else if(w >= 645 && w <= 780) {
					R = 1.0;
					G = 0.0;
					B = 0.0;
				}
			}
			return "rgb("+parseInt(R*255)+","+parseInt(G*255)+","+parseInt(B*255)+")";
		}
		
	  /** Error Handling. See: https://socket.io/docs/client-api/ **/
	  socket.on('connect_error', function() {console.log("Waveform: connect_error or connect_timeout");});
	  socket.on('disconnect', function() {console.log("Waveform: disconnected");});
    </script>
  </body>
</html>
