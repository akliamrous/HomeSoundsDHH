<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Real Time Chart Multi</title>
  <link rel=stylesheet type=text/css
    href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.2/css/bootstrap.min.css" media="all">
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js"></script>
  <style>
    html, body {
      background-color: #f5f5f5;
      width: 100%;
      height: 100%
    }

    .axis text {
      font: 12px helvetica;
      fill: #555;
    }

    .chartTitle {
      font-size: 12px;
      font-weight: bold;
      text-anchor: middle;
    }

    .axis .title {
      font-weight: bold;
      text-anchor: middle;
    }

    .axis path,
    .axis line {
      fill: none;
      stroke: #555;
      shape-rendering: crispEdges;
    }

    .x.axis path {
      fill: none;
      stroke: #555;
      shape-rendering: crispEdges;
    }

    .nav .area {
      fill: lightgrey;
      stroke-width: 0px;
    }

    .nav .line {
      fill: none;
      stroke:#555;
      stroke-width: 1px;
    }

    .well {
      padding-top: 0px;
      padding-bottom: 0px;
    }
  </style>

<body>

  <div style="padding-left: 17px">

    <div id="viewDiv"></div>

  </div>

  <script>
    'use strict';

    /* Socket variables */
    var FIRST_ROOM = "dj-home", SECOND_ROOM = "dj-office", THIRD_ROOM = "jon-office";
    var colors = [ "#ff7f0e", "#1f77b4", "#2ca02c", "#d62728", "#9467bd"];
    //var lengthOfGapInSec = 1;																	//Expected pause for an event to be marked set from server during handshake
    const heightGen = val => Math.log(val + Math.E) * 10;      //Generate height based on loudness. Max around 10

    /*chart variables */
    var version = "0.1.0",
      datum, data,
      maxSeconds = 300,
      svgWidth = $('body').width()*97.3/100, svgHeight = $('body').height()*93/100,
      margin = { top: 20, bottom: 38, left: 66, right: 5},
      dimension = { xAxis: 20, yAxis: 20, },
      drawXAxis = true, drawYAxis = true,
      xAxisDim = !drawXAxis ? 0 : dimension.xAxis,
      border,
      selection,
      barId = 0,
      yDomain = [],
      barWidth = 5,
      x, y, xNav,
      width = svgWidth - margin.left - margin.right,
      height = svgHeight - margin.top - margin.bottom - xAxisDim + 30,
      xAxisG, yAxisG,
      xAxis, yAxis,
      svg, 
      pixelsPerSecond = width / maxSeconds;

    /**** Data from Socket ****/

    var socket = io.connect({ 'reconnection': true, 'timeout': 5 * 86400 * 1000 });					//URL is windows.location (url address of the webpage), timeout: 5 days

    // Send handshake
    socket.on('connect', function () {
      console.log("Soundlist connected to server!");
      socket.emit('handshake', "http-soundlist");
    });

		socket.on('handshake-server-list', function (data) {
			data = JSON.parse(data);
			//lengthOfGapInSec = parseFloat(data.lengthOfGapInSec);

      //Should be set by server message
      chart.yDomain([THIRD_ROOM, SECOND_ROOM, FIRST_ROOM]);

      //list array: data.clientid, eventTimeStamp, duration, eventPeak, eventFreq
			for (var i = data.listArraylen; i < 100; i++)
			{
          var obj = {
          // complex data item; four attributes (type, color, opacity and size) are changing dynamically with each iteration (as an example)
          time: parseInt(data.listArray[i][1]),
          color: colorGenerator(data.listArray[i][0][0]),
          opacity: 0.4 + 0.6 * parseFloat(data.listArray[i][4]) / 5000, //max opacity: 0.5 for events to overlap...
          category: data.listArray[i][0],
          type: "rect",
          height: heightGen(parseFloat(data.listArray[i][3])),
          width: parseFloat(data.listArray[i][2]) * pixelsPerSecond
        };
          chart.datum(obj);
      }	
		});

    socket.on('responseFromHttpServer-soundlist', function (data) {
      data = JSON.parse(data);
      //console.log("Soundlist current level: "+ data.peakLoudness +  " event: " + data.event);

      var obj = {
        // complex data item; four attributes (type, color, opacity and size) are changing dynamically with each iteration (as an example)
        time: parseInt(data.eventTimeStamp),
        color: colorGenerator(data.clientid[0]),
        opacity: 0.4 + 0.6 * parseFloat(data.peakFrequency) / 5000, //max opacity: 0.5 for events to overlap...
        category: data.clientid,
        type: "rect",
        height: heightGen(parseFloat(data.peakLoudness)),
        width: parseFloat(data.duration) * pixelsPerSecond
      };

      window.requestIdleCallback(() => {
        chart.datum(obj);
      });
    });



    /** Error Handling. See: https://socket.io/docs/client-api/ **/
    socket.on('connect_error', function () { console.log("Soundlist: connect_error or connect_timeout"); });
    socket.on('disconnect', function () { console.log("Soundlist: disconnected"); });


    /***** Chart Creation *****/

    // create the real time chart
    var chart = realTimeChartMulti()
      .yDomain(["Room1"]) // initial y domain (note array)
      .border(true);

    // invoke the chart
    var chartDiv = d3.select("#viewDiv").append("div")
      .attr("id", "chartDiv")
      .call(chart);

    function colorGenerator(clientid) {
      switch (clientid) {
        case "dj-home": return colors[0];
        case "dj-office": return colors[1];
        case "jon-office": return colors[2];
        case "client-4-name": return colors[3];
        case "client-5-name": return colors[4];
      }
      return colors[0];
    }

    function realTimeChartMulti() {

      // create the chart
      var chart = function (s) {
        selection = s;
        if (selection == undefined) {
          console.error("selection is undefined");
          return;
        };

        // compute initial time domains...
        var ts = new Date().getTime();

        // first, the full time domain (max currently viewable time domain)
        var endTime = new Date(ts);
        var startTime = new Date(endTime.getTime() - maxSeconds * 1000);

        // append the svg
        svg = selection.append("svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight)
          .style("border", function (d) {
            if (border) return "2px solid lightgray";
            else return null;
          });

        // create main group and translate
        var main = svg.append("g")
          .attr("transform", "translate (" + margin.left + "," + margin.top + ")");

        // define clip-path
        main.append("defs").append("clipPath")
          .attr("id", "myClip")
          .append("rect")
          .attr("x", 0)
          .attr("y", 0)
          .attr("width", width)
          .attr("height", height);

        // create chart background
        main.append("rect")
          .attr("x", 0)
          .attr("y", 0)
          .attr("width", width)
          .attr("height", height)
          .style("fill", "#f5f5f5");

        // note that two groups are created here, the latter assigned to barG;
        // the former will contain a clip path to constrain objects to the chart area; 
        // no equivalent clip path is created for the nav chart as the data itself
        // is clipped to the full time domain
        var barG = main.append("g")
          .attr("class", "barGroup")
          .attr("transform", "translate(0, 0)")
          .attr("clip-path", "url(#myClip")
          .append("g");

        // add group for x axis
        xAxisG = main.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + height + ")");

        // add group for y axis
        yAxisG = main.append("g")                 //Group containing the axis and other things like "title" if needed
          .attr("class", "y axis");

        // define main chart scales
        x = d3.time.scale().range([0, width]);    // The time axis for interal maintenance
        y = d3.scale.ordinal().domain(yDomain).rangeRoundPoints([height, 0], 1);

        // define main chart axis
        xAxis = d3.svg.axis().orient("bottom");   //  What the user sees
        yAxis = d3.svg.axis().orient("left");

        // set the scale domains for main and nav charts
        x.domain([startTime, endTime]);

        // initial invocation; update display
        data = [];
        refresh();

        // function to refresh the viz upon changes of the time domain 
        // (which happens constantly), or after arrival of new data, or at init
        function refresh() {

          // process data to remove too late data items 
          data = data.filter(function (d) {
            if (d.time > startTime.getTime()) return true;
          })

          var updateSel = barG.selectAll(".bar")
            .data(data);

          // remove items
          updateSel.exit().remove();

          // add items
          updateSel.enter()
            .append(function (d) {
              if (d.type == undefined) console.error(JSON.stringify(d))
              var type = 'rect';
              var node = document.createElementNS("http://www.w3.org/2000/svg", type);
              return node;
            })
            .attr("class", "bar")
            .attr("id", function () {
              return "bar-" + barId++;
            });

          // update items; added items are now part of the update selection
          updateSel
            .attr("x", function (d) { return x(d.time); })
            .attr("y", function (d) { return y(d.category) - d.height / 2; })
            .attr("width", function (d) { return d.width; })
            .attr("height", function (d) { return d.height; })
            .attr("rx", 2)
            .attr("ry", 2)
            .style("fill", function (d) { return d.color || "black"; })
            //.style("stroke", "orange")
            //.style("stroke-width", "1px")
            //.style("stroke-opacity", 0.8)
            .style("fill-opacity", function (d) { return d.opacity || 1; });

        } // end refreshChart function


        /** Not checked but maybe this function can be used to create interactions with individual objects -- ToDo **/
        function getTagName(that) {
          var tagName = d3.select(that).node().tagName;
          return (tagName);
        }
        // function to keep the chart "moving" through time (right to left) 
        setInterval(function () {

          // compute new nav extents
          endTime = new Date();
          startTime = new Date(endTime.getTime() - maxSeconds * 1000);

          // update scales
          x.domain([startTime, endTime]);     //Internal time axis

          // update axis
          xAxis.scale(x)(xAxisG);             // What the user sees

          // refresh svg
          refresh();

        }, 60)

        return chart;

      } // end chart function


      // chart getters/setters

      // new data item (this most recent item will appear 
      // on the right side of the chart, and begin moving left)
      chart.datum = function (_) {
        if (arguments.length == 0) return datum;
        datum = _;
        data.push(datum);
        return chart;
      }

      // svg width
      chart.width = function (_) {
        if (arguments.length == 0) return svgWidth;
        svgWidth = _;
        return chart;
      }

      // svg height
      chart.height = function (_) {
        if (arguments.length == 0) return svgHeight;
        svgHeight = _;
        return chart;
      }

      // svg border
      chart.border = function (_) {
        if (arguments.length == 0) return border;
        border = _;
        return chart;
      }

      // yItems (can be dynamically added after chart construction)
      chart.yDomain = function (_) {
        if (arguments.length == 0) return yDomain;
        yDomain = _;
        if (svg) {
          // update the y ordinal scale
          y = d3.scale.ordinal().domain(yDomain).rangeRoundPoints([height, 0], 1);
          // update the y axis
          yAxis.scale(y)(yAxisG);
        }
        return chart;
      }


      // version
      chart.version = version;

      return chart;

    } // end realTimeChart function

  </script>