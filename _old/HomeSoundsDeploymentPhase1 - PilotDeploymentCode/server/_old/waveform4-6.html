<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="description" content="">
	<meta name="author" content="jm3">
	<script src="https://d3js.org/d3.v5.min.js"></script>
	<script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
	<script src="/socket.io/socket.io.js"></script>
	<title>d3 audio waveforms</title>

	<!--<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Roboto:400,100|Raleway:400,200|Amatic+SC"> -->
	<style>
		* {
			margin: 0;
			font-family: Helvetica, Arial;
		}

		html {
			margin: 1.0em;
		}

		h1 {
			font-size: 48px;
			font-weight: bold;
		}

		h1 a,
		h1 a:visited {
			text-decoration: none;
			font-weight: normal;
			font-size: 90%;
			color: #000;
			border-bottom: 1px dashed #bbb;
		}

		h1 a:hover {
			color: red;
		}

		.waveform>svg,
		.waveform>div {
			border: 2px solid #ddd;
			height: 140px;
			margin-left: 20px;
			padding: 2px;
			position: relative;
			width: 600px;
			/* Change width to incorporate more elements, but reduce points */
			display: inline-block;
			/*overflow:     hidden;*/
		}

		h2 {
			margin-left: 3px;
			font-size: 22px;
			color: #999;
			position: absolute;
		}

		.waveform>div div.bar {
			background-color: red;
			position: absolute;
		}

		.waveform .svg1 rect {
			fill: red;
			/*opacity:  0.5;*/
		}

		.waveform .svg2 rect {
			fill: green;
			/*opacity:  0.5;*/
		}

		.marquee {
			color: #666;
			font-size: 12px;
			position: absolute;
			top: calc(100% - 14px);
			width: 100%;
			height: 100%;
			animation: marquee 28.4s linear;
			white-space: nowrap;
		}

		@keyframes marquee {
			100% {
				transform: translateX(-100%);
			}
		}
	</style>
</head>

<body>
	<div class="page">
		<div class="waveform">
			<div class="svg1">
				<h2>DJ's Home</h2>
			</div>
			<div class="svg2">
				<h2>DJ's Office</h2>
			</div>
		</div>
	</div>

	<script>
		/* Performance is increased by reducing the number of data points or by reducing data updatae time.
		 * If you reduce the number of data points, the granurality is lower and hence you can use the functions below (divide by 2 etc.) to make it all look better.
		 * Another trick (not recommended) is to increase the data updatae time while also increasing the points (coz generating 512 point time is not double of 256 point time)
		 * This way the eye wouldn't see big lines moving too fast....
		 */
		var FIRST_ROOM = "dj-home", SECOND_ROOM = "dj-office", THIRD_ROOM = "jon-office";

		var numOfPoints = 0;				// Number of points  = 256. Orig = 1024 (which increases granurality but decreases performance and also decreases speed of updatae of waveform)			
		var min_max_val = 6;	//7.5		// IMP: CHANGE BASED ON MIC VOLUME AND HOW IT LOOKS. Remeber that graph doesn't show all value.
		var max_val = min_max_val;

		//D3 specific elements
		var width = 600, height = 140;
		var bar_width = width / (numOfPoints);							// Dividing by 2 reduces the number of path points. This allows to reduce the array length above while keeping same granularity (width of bars) by introducing space between the bars	

		//Sound event specific elements
		var secToPerWidth = sec => sec * 100 / parseFloat($('.marquee').css('animationDuration'));		//This does not account for width of marquee element. TODO: Also, set the marquee element width based on server handshake (data sample size)
		var lengthOfGapInSec = 1;
		var numOfSamplesPerSec = 20;
		var firstTime = 1;

		/**** data from Socket ****/
		var socket = io.connect();					//URL is windows.location (url address of the webpage), timeout: 5 days

		// Send handshake
		socket.on('connect', function () {
			console.log("Waveform connected to server!");
			socket.emit('handshake', "http-waveform");
		});

		socket.on('handshake-server-wave', function (data) {
			data = JSON.parse(data);
			if (firstTime) {
				lengthOfGapInSec = parseFloat(data.lengthOfGapInSec);
				numOfSamplesPerSec = parseFloat(data.numOfSamplesPerSec);
				numOfPoints = parseInt(data.numOfWaveformPoints);
				bar_width = width / (numOfPoints);
				svg_creater(Array.from({ length: numOfPoints }, () => 0.1), '.svg1', min_max_val);
				svg_creater(Array.from({ length: numOfPoints }, () => 0.1), '.svg2', min_max_val);
				firstTime = 0;
			}
		});


		socket.on('responseFromHttpServer', function (data) {
			data = JSON.parse(data);

			if (data.clientid == FIRST_ROOM) {
				svg_updater(data.arrayWaveform[numOfPoints-1], ".svg1", min_max_val);		// Note that max_val is updated in the next cycle
				if (data.event != "Blank")
					event_adder(".svg1", data.event, parseFloat(data.duration), lengthOfGapInSec);
			}

			if (data.clientid == SECOND_ROOM) {
				svg_updater(data.arrayWaveform[numOfPoints-1], ".svg2", min_max_val);
				if (data.event != "Blank")
					event_adder(".svg2", data.event, parseFloat(data.duration), lengthOfGapInSec);
			}

		});
		//event_adder(".svg2", "Loud", 0.75, 1);
		/**** Events *****/
		function event_adder(clas, event, duration, gapLen) {
			var id = new Date().getTime();

			$(clas).append("<span class='marquee " + id + "'>" + event + ", " + duration + "s</span>");

			var time_adjust = parseFloat($('.marquee').css('animationDuration')) / (numOfPoints / numOfSamplesPerSec);
			var animationDuration = parseFloat($('.marquee').css('animationDuration')) - (duration + gapLen) * time_adjust;
			$('.' + id).css({ 'animationDuration': animationDuration + 's' });

			var tra = -secToPerWidth(duration + gapLen);
			$('.' + id).css({ 'transform': 'translateX(' + tra + '%)' });

			setTimeout(function () {
				$('.' + id).remove();
			}, animationDuration * 1000);
		}

		/**** Waveform *****/

		var y = d3.scaleLinear().range([height, -height]);     // range -> rangeRound will avoid 0.6, 0.7 etc. in axis
		y.domain([-max_val, max_val]);

		function svg_creater(data, svg, max_val) {

			var chart = d3.select(svg).append("svg")
				.attr("class", "chart")
				.attr("width", width)
				.attr("height", height);

			var grp = chart.append("g")
				.attr("transform", "translate(0,0)");

			grp.selectAll("rect")
				.data(data)
				.enter().append("rect")
				.attr("transform", function (d, i) {
					return "translate(" + i * bar_width + ",0)";
				})
				.attr("y", function (d) {
					return height - Math.abs(y(d) / 2) - height / 2 + 2;
				})
				.attr("height", function (d) {
					return Math.abs(y(d));
				})
				.attr("width", bar_width);
		}

		function svg_updater(data, svg, max_val) {

			var chart = d3.select(svg).select("svg");
			var grp = chart.select("g");
			var grpTransform = grp.attr("transform");
			var xCoor = (grpTransform.substring(grpTransform.indexOf("(") + 1, grpTransform.indexOf(")")).split(",")[0]) - bar_width;

			grp.attr("transform", "translate(" + xCoor + ",0)");

			grp.insert("rect")
				.attr("transform", function (d, i) {
					return "translate(" + (numOfPoints * bar_width - xCoor) + ",0)";
				})
				.attr("y", height - Math.abs(y(data[0]) / 2) - height / 2 + 2)
				.attr("height", Math.abs(y(data[0])))
				.attr("width", bar_width)
				.attr("opacity", 0.4 + 0.6*data[1] / 5000);

			/*grp.selectAll("rect")
			.attr("transform", function(d, i) {
							return "translate(" + (i-1) * bar_width + ",0)";
			})*/

			grp.select("rect")
				.remove();

			/*
			chart.selectAll("rect").data(data)
			.attr("y", function(d) { 
				return height - Math.abs(y(d[0]) / 2) - height / 2 + 2;
			})
			.attr("height", function(d) {
				return Math.abs(y(d[0]));
			})
			.attr("opacity", function(d){
					return 0.4 + 0.6*d[1]/5000;
			})
			*/
		}

		function pitch_to_color2(pitch) {
			var R = 0, G = 0, B = 0;
			if (pitch != 0)
				B = parseInt(pitch * 255 / 1000);				//anything about > 1000 is mapped to 255
			return "rgb(" + R + "," + G + "," + B + ")";
		}
		function pitch_to_color(pitch) {
			if (pitch != 0) {
				var w = parseInt(pitch * (780 - 380) / 5000) + 380;

				var R = 0.0, G = 0.0, B = 0.0;

				if (w >= 380 && w < 440) {
					R = -(w - 440) / (440 - 350);
					G = 0.0;
					B = 1.0;
				}
				else if (w >= 440 && w < 490) {
					R = 0.0;
					G = (w - 440) / (490 - 440);
					B = 1.0;
				}
				else if (w >= 490 && w < 510) {
					R = 0.0;
					G = 1.0;
					B = -(w - 510) / (510 - 490);
				}
				else if (w >= 510 && w < 580) {
					R = (w - 510) / (580 - 510);
					G = 1.0;
					B = 0.0;
				}
				else if (w >= 580 && w < 645) {
					R = 1.0;
					G = -(w - 645) / (645 - 580);
					B = 0.0;
				}
				else if (w >= 645 && w <= 780) {
					R = 1.0;
					G = 0.0;
					B = 0.0;
				}
			}
			return "rgb(" + parseInt(R * 255) + "," + parseInt(G * 255) + "," + parseInt(B * 255) + ")";
		}

		/** Error Handling. See: https://socket.io/docs/client-api/ **/
		socket.on('connect_error', function () { console.log("Waveform: connect_error or connect_timeout"); });
		socket.on('disconnect', function () { console.log("Waveform: disconnected"); });
	</script>
</body>

</html>